fun main() {

    fun getInitialStones(input: String): List<String> {
        return input.split(" ")
    }

    // fairly basic, inelegant method that simply converts the current stones into new stones
    // resulting in a stupidly large list of stones
    fun part1(input: String): Int {
        val stones = getInitialStones(input).toMutableList()

        for (blinkCount in 0..24) {
            var index = 0

            while (index in stones.indices) {
                if (stones[index] == "0") {
                    // if the number is zero, stone becomes a 1
                    stones[index] = "1"
                } else if (stones[index].length % 2 == 0) {
                    // if number has an even number of digits, split in half and create 2 stones
                    val numString = stones[index]
                    stones[index] = numString.substring(0..<numString.length / 2)
                    // .toLong() used to remove any leading 0's
                    stones.add(index + 1, numString.substring(numString.length / 2).toLong().toString())
                    index++
                } else {
                    // otherwise, stone becomes the current number multiplied by 2024
                    stones[index] = (stones[index].toLong() * 2024).toString()
                }
                index++
            }
        }
        return stones.size
    }

    // Hard to get a bit more creative here, as naively creating new stones, results in a LOT
    // of repetition/recalculation and long processing time.
    // Came up with a method to "remember" some combinations of stones/# of blinks to help reduce that
    fun part2(input: String): Long {
        val stones = getInitialStones(input).toMutableList()

        // Recursive function to find the number of stones created by specific stone number after
        // a specific number of blinks
        //
        // The "solved" Map tracks already calculated blinks, where key = (startNum, blinksLeft)
        // It returns the number of stones that this combination would generate to avoid a lot of repetition
        // during calculations
        fun solveStartNum(startNum: Long, blinksLeft: Int, solved: MutableMap<Pair<Long, Int>, Long>): Long {

            if (blinksLeft == 0) {
                // no blinks left, so the stone can't split, this combination results in exactly 1 stone
                return 1
            } else if (startNum to blinksLeft !in solved) {
                // we haven't seen this combination, so we need to solve it
                val numString = startNum.toString() // convert to String to make the split easier, if required

                // add new solved value
                solved[startNum to blinksLeft] = when {
                    // if the number is zero, next value to solve 1
                    startNum == 0L -> solveStartNum(1, blinksLeft - 1, solved)
                    // if the num has an even amount of digits, split in half and solve the 2 new numbers
                    numString.length % 2 == 0 -> {
                        //.toLong() helps remove leading 0's
                        val leftDigits = numString.substring(0 until numString.length / 2).toLong()
                        val rightDigits = numString.substring(numString.length / 2 until numString.length).toLong()
                        // now solve each half, sum of the solutions for the 2 halves is what we want for original startNum
                        solveStartNum(leftDigits, blinksLeft - 1, solved) + solveStartNum(
                            rightDigits,
                            blinksLeft - 1,
                            solved
                        )
                    }
                    // otherwise, solve for the number * 2024
                    else -> solveStartNum(startNum * 2024, blinksLeft - 1, solved)
                }
            }
            // return the new solved value
            return solved.getValue(startNum to blinksLeft)
        }

        var totalStones = 0L

        //This Map will hold already "solved" (StartNum,Blinks), to avoid a LOT of repetition/recalculation
        val solved = mutableMapOf<Pair<Long, Int>, Long>()

        val totalBlinks = 75

        stones.forEach { stone ->
            // get the total number of stones generated by each starting stone for the given number of blinks
            totalStones += solveStartNum(stone.toLong(), totalBlinks, solved)
        }
        return totalStones
    }

    // Read the input from the `src/Day11_input.txt` file.
//    val input = readInput("Day11_sample")
    val input = readInput("Day11_input")
    part1(input[0]).println()
    part2(input[0]).println()

}
